<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="A website for CS0330 students at Brown University">
        <meta name="author" content="CS0330 TA Staff">

        <title>Maze | CS0330</title>

        <!-- CSS -->
        <link href="../css/webhandouts.css" rel="stylesheet">
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    </head>
    <body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
      <h1>Maze</h1>
        <div class="webhandout">
          <p>Due: Wednesday, September 18, 2019 at 11:59pm</p>
          </div>
          <button class="foldable">1) Introduction</button>
          <div class="content">
          <p>Oh jeepers! While Tom was scoping the deep waters s-Pacifically for colorful octopuses to photograph for his underwater photo collection, he encountered a ghastly C-monster! In order to escape, Tom must create a maze of kelp to stump the C-monster and swim away to safety. Complete this assignment and help Tom flee the C-monster. Shrimply put, his life is in your hands!</p>
          </div>
          <button class="foldable">2) Assignment</button>
          <div class="content">
          <p>This C programming assignment contains two parts: first you will write a program <em>generator</em>, which generates mazes; then you will write a program <em>solver</em>, which solves those mazes.</p>
          <p>To get started, run:</p>
          <pre><code>cs0330_install maze</code></pre>
          <p>This will copy the stencil for this project into <strong>∼/course/cs0330/maze</strong>.</p>
          <p><strong>Note:</strong> it may be helpful to have access to a <a href="https://repl.it/languages/c">C compiler</a> to run and test any miscellaneous code.</p>
          </div>
          <button class="foldable">3) Stencil</button>
          <div class="content">
          <p>You do <strong>not </strong>need to modify <strong>generator.h</strong> or <strong>solver.h</strong>. You <strong>will </strong>need to modify <strong>generator.c</strong>, <strong>solver.c</strong>, <strong>common.c</strong>, and <strong>common.h</strong>. We recommend implementing the functions (and structs) in the following order:</p>
          <p>Start with <strong>common.c</strong>:</p>
          <ol>
          <li><p>maze_room struct</p></li>
          <li><p>initialize_maze function</p></li>
          <li><p>is_in_range function</p></li>
          <li><p>get_neighbo function</p></li>
          </ol>
          <p>Then in generator.c:</p>
          <ol>
          <li><p> get opposite dir  function</p></li>
          <li><p> shuffle_array function</p></li>
          <li><p> drunken_walk function</p></li>
          <li><p> encode_room function</p></li>
          <li><p> encode_maze function</p></li>
          <li><p> main function</p></li>
          </ol>
	  <p>Finally in <strong> solver.c</strong>:</p>
          <ol>
          <li><p>create_room_connections function</p></li>
          <li><p>decode_maze function</p></li>
          <li><p>dfs</strong> function</p></li>
          <li><p> print pruned path  function</p></li>
          </ol>
          <p><strong>NOTE: This order is simply a recommendation. Feel free to implement these functions in whatever order you find most intuitive!</strong></p>
          </div>
          <button class="foldable">4) Maze Structure</button>
          <div class="content">
          <p>In the Life lab, you learned how to index into a one-dimensional array to represent a two-dimensional array. In this project, however, we will be representing mazes as actual two-dimensional arrays.</p>
          <p>Room indices start as <strong>(0,0) </strong>at the <strong>top left corner</strong>, and grow as you move down and to the right. This means the lower-right corner of a <strong>10 × 25 </strong>maze would have coordinates <strong>(9,24)</strong>.</p>
          <p>Each room will have either a <strong>wall</strong> (stored as a <strong>1</strong>) or an <strong>opening</strong> (stored as a <strong>0</strong>) for each possible direction (North, South, West, East). Connections should be consistent between rooms, and rooms on the edges should always have a wall in that direction (or two walls, in the case of corners).</p>
          <p><img src="image_0.png" alt="image alt text" /></p>
          <p>You <strong>must</strong> use a <strong>2D array</strong> to represent your maze. The stencil declares maze arrays as</p>
          <p>struct maze_room maze[num_rows][num_cols]</p>
          <p>This shows up in the signature of each function, be sure to build your maze array in the same way. <strong>Always make sure the first index is the row, and the second index is the column.</strong></p>
          <p>For each room, you will need to keep track of the following:</p>
          <ul>
          <li><p>the <strong>row</strong> and <strong>column</strong> of the room.</p></li>
          <li><p>whether or not the room has been visited.</p></li>
          <li><p>for each connection of the room, whether that connection is a wall, opening, or is uninitialized.</p></li>
          </ul>
          <p>Make sure you initialize all values.</p>
          </div>
          <button class="foldable">5) Generator</button>
          <div class="content">
          <p>The first part of this project will be to generate a maze.</p>
	  <button class='foldable sub'>5.1 Algorithm</button>
	  <div class='content'>
          <p>There are a few ways to generate a maze, but the simplest uses the recursive <em>drunken-walk algorithm</em>. This algorithm chooses a random order in which to visit each room of the maze, and then creates walls based on that order.</p>
          <p>Since rooms that haven’t been visited yet are guaranteed to have an opening to a previous room, it is guaranteed that there will be a path from any room to any other room in the maze.</p>
          <p>Pseudocode:</p>
          <p>drunken_walk(row, col):</p>
          <pre><code>r = rooms[row][col]

          set r.visited to true

          for each direction dir in random order:

              if (row + row_offset of dir, col + col_offset of dir) is out of bounds:

                  store a wall in r at direction dir

              else:

                 neighbor = rooms[row + row_offset of dir][col + col_offset of dir]

                  if neighbor has not yet been visited:

                      store an opening in r at direction dir

                      drunken_walk(neighbor.row, neighbor.col)

                  else:

                      opposite_dir = the opposite direction of dir

                      if neighbor has a connection c (opening or wall) in direction opposite_dir:

                          store c in r at direction dir

                      else:

                          store a wall in r at direction dir</code></pre>
	  </div>
	  <button class='foldable sub'>5.2 Random Number Generation</button>
	  <div class='content'>
		  <p>To ensure that the maze generated by your program is different every time, you’ll need to use C’s <strong>rand()</strong> function, which takes no arguments and returns an integer between <strong>0</strong> and <strong> RAND_MAX </strong>. To get a random number between <strong> 0 </strong> and <strong>n-1</strong>, you can take <strong>rand() % (n)</strong>.</p>
          <p>The <strong>rand()</strong> function is actually a <em>pseudorandom number generator,</em> meaning that it outputs a consistent sequence of values when given a particular seed value. By default, <strong>rand()</strong> has a seed value of 1, so <strong>unless you change this, your program will generate the same sequence of random numbers each time it is run.</strong></p>
          <p>To change the seed value, include the line <strong>srand(time(NULL))</strong> at the beginning of your <strong>main()</strong> function.</p>
          <p>To randomize the order of directions through which you will search, declare the directions in some fixed order in an array. Then the following algorithm can be used to shuffle that array in-place:</p>
          <pre><code>shuffle_array(A[n]):

              for i from 0 to n-1:

                  choose a random number r between i and n-1, inclusive

                  switch A[i] and A[r]</code></pre>
          <p>This procedure produces all possible orderings with equal probability.</p>
          </div>
	  </div>
	  <button class="foldable">6) Solver</button>
          <div class="content">
          <p>The second part of this project is to write a solver that will solve the mazes the you (or we) generate.</p>
          <p><strong>Note: </strong>For this part of the project, add a maze_room pointer called <strong>next</strong> as a field into your struct maze_room definition. This will be useful in keeping track of the path.</p>
	  <button class='foldable sub'>6.1 Algorithm</button>.
	  <div class='content'>
          <p>Your program should employ a <em>depth-first search</em>. Such a search begins at the maze’s start room and explores adjacent, accessible rooms recursively.</p>
          <p>Beginning with the indicated room, this algorithm repeatedly chooses a path from each room and follows that path until it reaches a dead end, at which point it backtracks and tries a new path. This process continues until all paths have been explored or the destination is found. The following is pseudocode for this algorithm.</p>
          <p>dfs(row, col):</p>
          <pre><code>if (row, col) are the coordinates of the goal

              return true

          mark the room at [row][col] as visited

          for each direction dir:

              neighbor = rooms[row + row_offset of dir][col + col_offset of dir]

              if the connection in direction dir is open and neighbor is unvisited:

                  if dfs(neighbor.row, neighbor.col) is true

                      return true

          /* if the program reaches this point then each neighbor’s branch

              has been explored, and none have found the goal. */

          return false</code></pre>
	  </div>
	  <button class='foldable sub'> 6.2 Solution Output</button>
	  <div class='content'>
          <p>Your program should print a list of rooms to the given output file. The room coordinates should be formatted in the following format when printed to the solution file: <row>, <col></p>
          <p>Here’s an example of what the first several rows of your solution file might look like.</p>
          <p>PRUNED</p>
          <p>0, 0</p>
          <p>1, 0</p>
          <p>1, 1</p>
          <p>1, 2</p>
          <p>2, 2</p>
          <p>…</p>
          <p>We expect your solver to produce two different modes of output:</p>
          <ul>
          <li>Your program outputs the coordinates of only the final route from beginning to end. Your program should first print the line <strong>&quot;PRUNED&quot;</strong>. The program should then print the coordinates of each room on the solution path as described earlier.</li>
          </ul>
          <p>To do this, build a list of rooms as you search, and print out each room in the list when you reach the destination room. You can accomplish this using pointers! Use the provided <strong>next</strong> pointers in your room structs to maintain a linked list of rooms - when you move from room <em>A</em> to room <em>B</em>, set room <em>A</em>’s pointer to room <em>B</em>.</p>
          <ul>
          <li>Your program outputs the entire path traversed up until the goal is reached. Your program should first print the line <strong>&quot;FULL&quot;</strong>. The program should then print each room’s coordinates when first visiting that room, and after each recursive call that returns false. This will print the path from start to finish, including “backtracking” after dead ends.</li>
          </ul>
          <p><strong>Note:</strong> Depending on how your solver algorithm searches the maze, there can be multiple valid FULL solutions.</p>
          <p>The choice should be made when your program is compiled. This is done using preprocessor macros. Macros are defined using the gcc compiler flag <strong>-D<macro></strong>, which defines <strong><macro></strong> for the preprocessor. For example, to add the macro <strong>PIZZA</strong> to your program, add the flag <strong>-DPIZZA</strong>. In your Makefile, you’ll see the flag <strong>-DFULL</strong> in the command for the **solver_full** target, which defines the macro <strong>FULL</strong> for that target.</p>
          <p>To write code that will execute only when a specific macro is defined, refer to the example below:</p>
ifdef FULL
          <p>printf(<something>);</p>
    else

          <p>printf(<something else>);</p>
        endif
          <p>The above code fragment executes the <strong>printf(<something>)</strong> statement only if the macro <strong>FULL</strong> is defined, and executes the <strong>printf(<something else>)</strong> statement otherwise. You can also use the macro <strong>#ifndef</strong>** ****<macro>** to execute code only if <strong><macro></strong> is not defined.</p>
          <p>Your program should print the entire search if a macro <strong>FULL</strong> is defined and print only the path to the exit otherwise. Rooms should be printed with format <strong><row>, <col></strong> on its own line with no parentheses with the upper-left corner of the maze corresponding to coordinate (0, 0). If the start and end rooms happen to be the same, your output should contain the room only once.</p>
          </div>
	  </div>
          <button class="foldable">7) Compiling and Running</button>
          <div class="content">
          <h2>7.1 How to Build</h2>
          <p>Makefile table</p>
          <table>
            <tr>
              <td>Command</td>
              <td>Function</td>
            </tr>
            <tr>
              <td>make <target> </td>
              <td>Builds a particular target. If no target is specified, it will build the first target (in this case, the target all).</td>
            </tr>
            <tr>
              <td>make clean </td>
              <td>Removes any previously built targets</td>
            </tr>
            <tr>
              <td>make generator </td>
              <td>Builds your generator program</td>
            </tr>
            <tr>
              <td>make solver </td>
              <td>Builds your solver program with no macros defined (i.e. the program should print pruned output)</td>
            </tr>
            <tr>
              <td>make solver_full </td>
              <td>Builds your solver program with the FULL macro defined (i.e. the program should print its full exploration path).</td>
            </tr>
            <tr>
              <td>make all (or just make)</td>
              <td>Builds EVERYTHING (your generator, solver, and solver_full programs)</td>
            </tr>
            <tr>
              <td>make clean all</td>
              <td>Shorthand for running  make clean followed by make all</td>
            </tr>
          </table>
          <p>You have been provided a <em>Makefile</em>, a text file that contains scripts for compiling, running, or cleaning up projects (for example).</p>
	  <p>Makefiles contain <em>build targets</em>; if we look at the Makefile included in this project we can see that there are 5 targets: <strong>all</strong>, <strong>generator</strong>, <strong>solver</strong>, <strong> solver_full</strong> and <strong>clean</strong>. Each target has an associated command and optional dependencies. In order to test the first half of the assignment, you will only need <strong>generator</strong> and <strong>clean</strong>.</p>
          <p>The make command only builds files that have been modified since the last build and allows you to split up your build process (e.g. splitting up maze generator and maze solver binaries to be built).</p>
          <h2>7.2 Running</h2>
          <p>Once you have compiled the generator portion of the project, you can run it with the command:</p>
          <pre><code>    ./generator &lt;output maze file&gt; &lt;# of rows&gt; &lt;# of columns&gt;</code></pre>
          <p><strong>Note:</strong> mazes that are very large may segmentation faults, so we will not test your code with a maze of a size larger than 250 x 250.</p>
          <p>Once you have compiled your solver, you can run it with the command</p>
          <p>./solver <input maze file> &lt;# of rows&gt; &lt;# of columns&gt;</p>
          <pre><code>&lt;output solution file&gt; &lt;starting row&gt; &lt;starting column&gt;

          &lt;ending row&gt; &lt;ending column&gt;</code></pre>
          <p>or</p>
          <p>./solver_full <input maze file> &lt;# of rows&gt; &lt;# of columns&gt;</p>
          <pre><code>       &lt;output solution file&gt; &lt;starting row&gt; &lt;starting column&gt;

                 &lt;ending row&gt; &lt;ending column&gt;</code></pre>
          <h2>7.3 Support</h2>
          <p>In order to test your generator before moving onto the next section, we’ve provided the following three programs. **cs0330<em>maze</em>generator<em>demo**** <strong>and </strong>cs0330</em>maze_validator** will accept maze input of any size, but <strong>cs0330<em>maze</em>viewer</strong> is designed to only accept mazes with 10 rows and 25 columns. Please only use it with mazes of these dimensions or you will receive errors (even if your code is correct!).</p>
          <ul>
          <li>cs0330_maze_generator_demo <output maze file> &lt;# of rows&gt; &lt;# of columns&gt;**</li>
          </ul>
          <p>This program demonstrates the expected behavior of your <strong>generator</strong> program. It generates a maze in output_fil*.</p>
          <ul>
          <li>cs0330_maze_validator <maze file></strong></li>
          </ul>
          <p>This program will check your maze for errors, such as inconsistent or missing walls and inaccessible areas. Please make sure to validate your generated maze before moving on.</p>
          <ul>
          <li>cs0330_maze_viewer <maze file></strong></li>
          </ul>
          <p>This script will open your maze in a graphical interface. <strong>This script only works with mazes of size 10x25.</strong></p>
          <p>To test the solver portion of this assignment, you are provided with the following programs. Except for cs0330_maze_solution_viewer, which is designed to only accept mazes with 10 rows and 25 columns, all of these scripts should work with mazes of any size.</p>
          <ul>
          <li><p>cs0330<em>maze</em>solver_demo <input maze file> &lt;# of rows&gt; &lt;# of columns&gt;</p>
          <pre><code>    &lt;output solution file&gt; &lt;starting row&gt; &lt;starting column&gt;

              &lt;ending row&gt; &lt;ending column&gt;</code></pre></li>
          </ul>
          <p>This is a demo program for the solver project; it produces pruned output, i.e. just the path from the start coordinate to the end coordinate.</p>
          <ul>
          <li><p>cs0330<em>maze</em>solver<em>full</em>demo <input maze file> &lt;# of rows&gt; &lt;# of columns&gt;</p>
          <pre><code>    &lt;output solution file&gt; &lt;starting row&gt; &lt;starting column&gt;

              &lt;ending row&gt; &lt;ending column&gt;</code></pre></li>
          </ul>
          <p>This is a demo program for a solver’s full output. It produces a list of rooms in the order in which they were explored.</p>
          <ul>
          <li><p>cs0330<em>maze</em>validator <maze file> <solution file></p>
          <p><starting row> <starting column></p>
          <p><ending row> <ending column></p></li>
          </ul>
          <p>This program will also validate a solution file (if you provide it one) for a maze. Make sure the end-point coordinates correspond to those given to your solver.</p>
          <ul>
          <li>cs0330_maze_solution_viewer <maze file> <solution file> <speed></li>
          </ul>
          <p>This program will visualize your solution path in the provided maze. The <strong><speed></strong> argument to cs0330_maze_solution_viewr must be an integer between 1 and 3, inclusive; higher values make Mike, Sulley, and Boo move faster. If either the maze or the solution file is improperly formatted, the visualizer will exit.</p>
          <p>This program will also check your input files for correctness, and will print out a list of errors if problems are found.</p>
          </div>
          <button class="foldable">8) Maze Encoding, Decoding, and Translating</button>
          <div class="content">
		  <button class='foldable sub'> 8.1 Encoding and Decoding</button>
		  <div class='content'> 
          <p>In order for you to save the mazes you generate, to later read and solve them, you need some way to represent them in a file. <strong>Each line of this file will correspond to a row of rooms.</strong> Since each room has four connections, each of which can be in one of two states (wall or opening), there are 24 = 16 possible configurations a room can be in.</p>
          <p>We want a concise way to encode each room (ideally a single character). Since each room can be in one of 16 unique states, we can store each room as a hexadecimal (hex) number. This lets each room be encoded as a single character, which is only one byte long!</p>
          <p>Hexadecimal numbers are made up of four bits, and each room has four connections, so each bit can represent a single connection. Specifically,</p>
          <ul>
          <li><p>the highest-order bit represents the <strong>east</strong> connection</p></li>
          <li><p>the next-highest bit represents the <strong>west</strong> connection</p></li>
          <li><p>the next-lowest bit represents the <strong>south</strong> connection</p></li>
          <li><p>the lowest-order bit represents the <strong>north</strong> connection</p></li>
          </ul>
          <p>As an example, a room with walls to the east, south, and north, and an opening to the west would be represented as <strong>1101</strong>, which is <strong>13</strong>** <strong>in decimal, or </strong>D <strong>in hex. (</strong>0b1101<strong>, </strong>13<strong>, </strong>0xd** respectively)</p>
          <p><strong>NOTE: Your maze MUST conform to this specification.</strong></p>
		  </div>
		  <button class='foldable sub'>8.2 Translating Between Representations</button>
		  <div class='content'>
          <p>For <strong>generator</strong>, you must translate from the program representation of the maze to the file representation. To do this, you need a way to convert from a four-bit binary number to one hexadecimal character.</p>
          <p>There are a few ways to do this, such as bit-shifting, but a simpler way is to convert by hand to decimal and delegate the hexadecimal conversion to <strong>fprintf()</strong>. Each bit corresponds to a power of two:</p>
          <table>
            <tr>
              <td>E</td>
              <td>W</td>
              <td>S</td>
              <td>N</td>
            </tr>
            <tr>
              <td>8</td>
              <td>4</td>
              <td>2</td>
              <td>1</td>
            </tr>
          </table>
          <p>As per the example before, a room with connections <strong>1100</strong> would be represented with</p>
          <p><strong>1(8) + 1(4) + 0(2) + 0(1) = 12</strong>, or <strong>0xC</strong> in hexadecimal.</p>
          <p>Once you have a decimal representation of your room, there is a lovely trick you can pull to print out a hex value: instead of giving <strong>fprintf()</strong> <strong>&quot;%d&quot;</strong>, you can give it <strong>&quot;%x&quot;</strong> and it will print your decimal value as a hex character. As an example, the following is a sample maze representation in a file, where each hexadecimal number represents a room’s connections:</p>
          <p>597333331395397313333313b</p>
          <p>c6339595adccd639633b59639</p>
          <p>cd53286a70ac619c5333a639c</p>
          <p>c4a59e5396969cc6ad51b53ac</p>
          <p>ce5a632bc5a5ac61b4ac5a738</p>
          <p>432339ddcc5a5adc5ad6a5958</p>
          <p>cd5396accccdc58cc5239c6ac</p>
          <p>cccd633accc4aec6a639cc59c</p>
          <p>68c43339cccc5949719cc6acc</p>
          <p>7a6a7332a6a6a6a63a6a633ae</p>
          <p>For your <strong>solver</strong>, you must translate from the file representation written in <strong>generator </strong>to the program representation. Fortunately, we’ve already written the code to read from the output file containing the encoded maze created by your generator (<strong>read<em>encoded</em>maze<em>from</em>file</strong>), so you will need to properly convert it back into an integer before you can perform any operations on the hexadecimal characters in the file.</p>
          <p>Once you have the hexadecimal number back in decimal form, use bit-level operations to extract the room data. To extract a particular element, use a <em>bit mask</em>, or an integer whose binary representation consists entirely of zeros except for a particular bit (or bits). Some examples include <strong>0x4</strong>** (****0100****)** and <strong>0x1</strong>** (****0001****)**.</p>
          <p>To use bit masks, perform a bitwise <strong>AND (&amp;)</strong> on the mask and the integer to be masked. The <strong>AND </strong>operator compares each bit of the two operands. If both bits are 1, then the corresponding resultant bit is set to 1. Otherwise, it is set to 0. Some examples are:</p>
          <pre><code>      1011 (0xb)                1011 (0xb)

              &amp; 0010 (0x2)              &amp; 0100 (0x4)

                0010 (0x2)                0000 (0x0)</code></pre>
          <p>In C:** 0xb &amp; 0x2 = 0x2 0xb &amp; 0x4 = ****0x0**</p>
          </div>
	  </div>
          <button class="foldable">9) Input and Output</button>
          <div class="content">
          <p>For this assignment, we have gone ahead and written the code to write to an output file in <strong>generator.c</strong> and to read from the file in <strong>solver.c.</strong></p>
          <p>In <strong>generator.c</strong>, we use the C library function <strong>fprintf</strong> to write the encoded maze to a file. In order to properly write to a file, it’s important to open the file with <strong>fopen</strong> and supply the file name and read/write mode. If successful, then <strong>fprintf</strong> can write to the opened file. When you are done writing, it’s important to close the file with <strong>fclose</strong> and supply the file name.</p>
          <p>In <strong>solver.c</strong>, we want to read the encoded maze from a file. Similar to the process of writing in <strong>generator.c</strong>, we want to open the file up with <strong>fopen</strong> and read using <strong>fscanf</strong>, which takes a filename and a mode. When done, we want to again close the file with <strong>fclose</strong>.</p>
          <p>When using a library call, it is important to check the value the function returns. If the function returns a value associated with an error, it is important to report the error and handle it accordingly. All of the functions mentioned above can fail, so we have error checked these calls for you and printed appropriate error messages to <strong>stderr</strong> using <strong>fprintf</strong>.</p>
          </div>
          <button class="foldable">10) Grading</button>
          <div class="content">
          <p>Your grade for this project will be calculated as follows:</p>
          <table>
            <tr>
              <td>Generator
          Solver
          Error Handling
          Style</td>
              <td>40%
          40%
          10%
          10%</td>
            </tr>
            <tr>
              <td>Total</td>
              <td>100%</td>
            </tr>
          </table>
          <p>Both generator and solver will be graded based on Code Correctness (15 pts) and Functionality (25 pts).</p>
          <ul>
          <li><strong>Code Correctness:</strong> no part of your code relies on undefined behavior, uninitialized values, or out-of-scope memory; your program compiles without errors or warnings.</li>
          </ul>
          <p><em>Only</em> <strong>cs0330<em>maze</em>validator</strong> <em>will be</em> <em>used during grading</em>. (i.e It’s ok if your maze doesn’t work in the visualizer.)</p>
          <ul>
          <li><p><strong>Functionality:</strong> your code produces correct output, and does not crash for any reason. It does not terminate due to a segmentation fault or floating point exception.</p></li>
          <li><p><strong>Error Handling:</strong> your code performs error checking on its function inputs and outputs, and exits gracefully in all situations. No input to your generator or solver should cause a segmentation fault.</p></li>
          <li><p><strong>Style:</strong> your code should look nice! Use appropriate whitespace and indentation and well-named variables and functions. Your code should be reasonably factored, and functions should not be too long. Make sure your functions have header comments, and if they already do then don't delete them!</p></li>
          </ul>
          <p>Your programs should perform error checking on their input, with one exception: if your solver program successfully opens a maze file, you may assume that the file contents form a correctly-formatted maze. Your program should not crash for any reason; before you hand in your project, make sure that your program does not terminate due to a segmentation fault or floating point exception.</p>
          <p>Consult the <strong><a href="http://cs.brown.edu/courses/cs033/docs/guides/style.pdf">Style Guid**e</a></strong> **for some pointers on C coding style. Note that you can run a style ting script in order to make your code match <em>some</em> of the style specifications. To use the script, run the command</p>
          <pre><code>cs0330_reformat &lt;file1&gt; &lt;file2&gt; …</code></pre>
          <p>To reformat all .c and .h files in your current directory, you may run:</p>
          <pre><code>cs0330_reformat *.c *.h</code></pre>
          <p>Check the style guide for more information.</p>
          <p><strong>Note:</strong> the reformat script should only be used on .c and .h files</p>
          </div>
          <button class="foldable">11 Handing In</button>
          <div class="content">
          <p>To hand in your project, run the command</p>
          <p>cs0330_handin maze</p>
          <p>from your project working directory. You should hand in <strong>ALL FILES</strong> (<strong>common.c</strong>, <strong>common.h</strong>, <strong>generator.c</strong>, <strong>generator.h</strong>, <strong>solver.c</strong>, <strong>solver.h</strong>, along with any support code you may have written), a <strong>Makefile</strong>, and a <strong>READ</strong>. Your <strong>README</strong> should describe the organization of your programs and any unresolved bugs.</p>
          <p>If you wish to change your handin, you can do so by re-running the script. Only your most recent handin will be graded.</p>
          <p><strong>Important note: </strong>In order to get grades back to the class in a timely manner, we will have to start grading before the final deadline to submit an assignment for any credit has passed (6 days after the on-time deadline). Since students may hand in multiple times, and we always grade the most recent handin, we need a way of knowing not to start grading students who are planning to hand in again later.</p>
          <p><em>If you have already handed in your assignment, but plan to hand in again after the TAs start grading at noon on Saturday, September 21st, you must run </em>**cs0330<em>grade</em>me_late maze** <em>to inform us. You must run the script by noon on 9/21</em>. <strong>If you run this script, you will get grades back later than other students.</strong></p>
          <p>If you do not run this script, the TAs will proceed to grade whatever you have already handed in, and you will receive a grade report with the rest of the class that is based on the code you handed in before we started grading. It would be unfair to ask your UTAs to re-grade your new code after they’ve already put time and effort into grading your original handin.</p>
          <p>Exercise caution when running this script: by running it, you forfeit the privilege of on-time feedback. If something changes, you can run the script with the <strong>--undo</strong> flag (before noon on 9/21) to tell us to grade you on-time and with the <strong>--info</strong> flag to check if you’re currently on the list for late grading.</p>
          <p>These instructions apply to all projects unless otherwise stated on the handout; the deadline to run the script will be noon on the Saturday after each assignment is due.</p>
          </div>

          <!-- Your content here -->
      </div>

        <!-- Footer -->
        <footer>
        <div class="container text-center">
            <p>
            &copy; 2019 CS0330 TA Staff
            <span class="spacing">|</span>

            <a href="http://cs.brown.edu">Computer Science Department</a>
            <span class="spacing">|</span>
            <a href="http://brown.edu">Brown University</a>
            </p>
        </div>
        </footer>

        <!-- Javascript files -->
        <script src="../js/jquery.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script src="../js/jquery.easing.min.js"></script>
        <script src="../js/cs33.js"></script>
    </div>
    </body>
</html>
